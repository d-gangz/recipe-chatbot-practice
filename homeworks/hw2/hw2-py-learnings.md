## HW2 Python Guidelines

1. **Model real data with typed schemas.** Define Pydantic models for every payload you move across functions or persistence layers. Keep them small and composable (e.g., combine `DimensionTuple` into `DimensionTuplesList`) so future fields slot in without breaking callers.
2. **Surface configuration as constants.** Place knobs like `MODEL_NAME`, `MAX_WORKERS`, and output paths near the top of the module. This keeps tuning isolated from business logic and encourages reuse across scripts.
3. **Load secrets at startup.** Call `load_dotenv()` (or the appropriate loader) before any code references environment variables. Fail fast if required keys (such as `OPENAI_API_KEY`) are missing.
4. **Isolate external API access behind helpers.** Wrap third-party calls (`call_llm`) with retry/backoff logic and a consistent response interface so swapping providers or handling errors is confined to one function.
5. **Parallelize with traceability.** When using `ThreadPoolExecutor`, store a mapping from each `Future` to its originating input (index or metadata). Iterate with `as_completed` so you can stream progress and reattach context to results or exceptions.
6. **Deduplicate deterministically.** When collecting generated data, derive a hashable signature (e.g., `model_dump_json`) and track it in a `set`; append the full object to the output list only when the signature is new.
7. **Instrument long-running loops.** Pair `tqdm` progress bars (or similar) with `as_completed` to surface real-time status while preserving exception handling that keeps the batch moving.
8. **Keep outputs structured until the very end.** Build lists of dicts from your Pydantic models, convert to a pandas `DataFrame`, and let `to_csv` or `to_sql` handle serialization. This avoids bespoke CSV code and unlocks easy SQLite export when needed.
9. **Provide a starter scaffold.** New scripts should follow the same skeleton: imports + config constants, Pydantic models, helper functions (e.g., `call_llm`), main workflow functions (`generate_*`, `save_*`), and a `main()` entry point guarded by `if __name__ == "__main__"`.
10. **Comment non-obvious comprehension patterns.** When using list or dict comprehensions for mappings, leave brief comments explaining why indexes or metadata are stored; new contributors should not need to reverse-engineer the intent.
11. **Prefer `pathlib.Path` for filesystem access.** Compose paths with `Path(__file__).parent` and friends to keep scripts portable across environments and operating systems.
12. **Stabilize imports in stand-alone scripts.** For CLI tooling that lives outside the package root (e.g., `scripts/`), resolve the project root with `Path(__file__).resolve().parent.parent` and insert it into `sys.path` before local imports; this prevents brittle relative-import hacks.
13. **Adopt consistent logging/print conventions.** Log high-level milestones (“Step 1…”, “Saved X queries”), report recoverable errors inline, and surface fatal conditions with early returns. For longer-running loops, use terminal-friendly tooling (`tqdm` progress bars or Rich panels/progress components) so operators can monitor status without digging into logs.
